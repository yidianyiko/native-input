# 简化认证系统需求文档

## 核心流程

用户点击登录 → 浏览器登录 → 返回API密钥和用户信息 → 客户端保存并使用

## 客户端接口规范

### 浏览器回调接口

作为Windows客户端，我们只需要知道浏览器如何将数据返回给我们：

#### 1. 客户端发起登录
```python
# 客户端打开浏览器到登录页面
def login(self) -> bool:
    state = secrets.token_urlsafe(16)  # 生成随机状态码
    auth_url = f"{self.login_url}?client=reinput&state={state}"
    webbrowser.open(auth_url)  # 打开浏览器
    return True
```

**登录URL格式**:
```
http://localhost:5174/login?client=reinput&state=xyz123
```

#### 2. 浏览器回调格式
登录成功后，浏览器会通过以下URL格式返回数据给客户端：

```
reinput://auth/callback?api_key=sk-xxx&username=john&email=john@example.com&state=xyz123
```

**参数说明**:
- `api_key`: 用户的API密钥（**必需**）
- `username`: 用户名（**必需**）  
- `email`: 邮箱地址（**可选**，可以为空）
- `state`: 原始请求中的state参数（**必需**，用于验证防止CSRF攻击）

#### 3. 客户端处理回调
```python
def _handle_command_line_url(self) -> None:
    """处理浏览器返回的URL"""
    if len(sys.argv) > 1 and sys.argv[1].startswith('reinput://'):
        url = sys.argv[1]
        parsed = urlparse(url)
        
        if parsed.path == '/auth/callback':
            query_params = parse_qs(parsed.query)
            
            # 提取必需参数
            api_key = query_params.get('api_key', [None])[0]
            username = query_params.get('username', [None])[0]
            email = query_params.get('email', [None])[0]  # 可选
            state = query_params.get('state', [None])[0]
            
            if api_key and username and state:
                # 验证state参数，处理登录成功
                self.auth_manager.handle_callback(api_key, username, email)
```

### 客户端数据结构

#### 用户信息
```python
@dataclass
class UserInfo:
    username: str
    email: Optional[str] = None
    login_time: Optional[datetime] = None
```

#### 会话存储格式
```json
{
    "api_key": "sk-1234567890abcdef",
    "user_info": {
        "username": "john_doe",
        "email": "john@example.com",
        "login_time": "2024-01-01T12:00:00"
    }
}
```

### 认证管理器接口
```python
class SimpleAuthManager:
    def login(self) -> bool:
        """启动浏览器登录"""
        
    def handle_callback(self, api_key: str, username: str, email: str = None) -> bool:
        """处理浏览器回调"""
        
    def logout(self) -> None:
        """登出，清除本地数据"""
        
    def is_authenticated(self) -> bool:
        """检查是否已登录"""
        
    def get_api_key(self) -> Optional[str]:
        """获取API密钥"""
        
    def get_user_info(self) -> Optional[UserInfo]:
        """获取用户信息"""
```

## 需要的功能

### 1. 浏览器登录启动
- **功能**: 用户点击登录按钮，打开浏览器到登录页面
- **已实现**: `src/logic/auth_manager.py` 中的 `login()` 方法
- **依赖**: `webbrowser` 模块

```python
def login(self) -> bool:
    """启动浏览器登录"""
    import secrets
    import webbrowser
    
    state = secrets.token_urlsafe(16)
    auth_url = f"{self.login_url}?client=reinput&state={state}"
    webbrowser.open(auth_url)
    return True
```

### 2. URL Scheme回调处理
- **功能**: 浏览器登录成功后通过 `reinput://` 协议返回信息
- **已实现**: `src/main.py` 中的 URL scheme 注册和处理
- **依赖**: Windows 注册表操作 (`winreg`)

#### 2.1 URL Scheme注册 (已实现)
```python
def _register_url_scheme(self) -> None:
    """Register reinput:// URL scheme for authentication callbacks"""
    try:
        import winreg
        
        # Register the protocol
        key_path = r"SOFTWARE\Classes\reinput"
        with winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path) as key:
            winreg.SetValue(key, "", winreg.REG_SZ, "URL:reInput Protocol")
            winreg.SetValueEx(key, "URL Protocol", 0, winreg.REG_SZ, "")
        
        # Set the command handler (handle both frozen exe and python script)
        command_path = f"{key_path}\\shell\\open\\command"
        with winreg.CreateKey(winreg.HKEY_CURRENT_USER, command_path) as key:
            exe_path = sys.executable
            if getattr(sys, "frozen", False):
                # Packaged executable
                command = f'"{exe_path}" "%1"'
            else:
                # Python interpreter + script path
                script_path = __file__
                command = f'"{exe_path}" "{script_path}" "%1"'
            winreg.SetValue(key, "", winreg.REG_SZ, command)
        
        self.logger.info("Successfully registered reinput:// URL scheme")
        
    except Exception as e:
        self.logger.error(f"Failed to register URL scheme: {e}")
```

#### 2.2 URL回调处理 (需要修改)
```python
def _handle_command_line_url(self) -> None:
    """Handle URL scheme from command line arguments"""
    try:
        # Check if URL was passed as command line argument
        if len(sys.argv) > 1 and sys.argv[1].startswith('reinput://'):
            url = sys.argv[1]
            self.logger.info(f"Received URL scheme: {url}")
            
            # Parse the URL
            from urllib.parse import urlparse, parse_qs
            parsed = urlparse(url)
            path = parsed.path or ""
            netloc = parsed.netloc or ""
            
            # Support both forms:
            # 1) reinput://auth/callback?api_key=... (netloc='auth', path='/callback')
            # 2) reinput:///auth/callback?api_key=... (path='/auth/callback')
            if path == '/auth/callback' or (netloc == 'auth' and path == '/callback'):
                query_params = parse_qs(parsed.query)
                
                # 新格式: 直接获取API密钥和用户信息
                api_key = query_params.get('api_key', [None])[0]
                username = query_params.get('username', [None])[0]
                email = query_params.get('email', [None])[0]
                state = query_params.get('state', [None])[0]
                
                if api_key and username and state:
                    # Store for processing after initialization
                    self.pending_api_key = api_key
                    self.pending_username = username
                    self.pending_email = email
                    self.pending_state = state
                    self.logger.info("Authentication callback received, will process after initialization")
                else:
                    self.logger.warning("Invalid authentication callback: missing required parameters")
                    
    except Exception as e:
        self.logger.error(f"Failed to handle command line URL: {e}")
```

### 3. 用户信息管理
- **功能**: 存储和显示用户名、邮箱、登录状态
- **需要实现**: 简化的用户信息数据结构

```python
from dataclasses import dataclass
from typing import Optional
from datetime import datetime
import json
import os

@dataclass
class UserInfo:
    username: str
    email: Optional[str] = None
    login_time: Optional[datetime] = None

class SimpleAuthManager:
    """简化的认证管理器"""
    
    def __init__(self, login_url: str):
        self.login_url = login_url
        self.api_key = None
        self.user_info = None
        self.session_file = "session.json"
        self._load_session()
    
    def is_authenticated(self) -> bool:
        """检查是否已登录"""
        return self.api_key is not None and self.user_info is not None
    
    def get_api_key(self) -> Optional[str]:
        """获取API密钥"""
        return self.api_key
    
    def get_user_info(self) -> Optional[UserInfo]:
        """获取用户信息"""
        return self.user_info
    
    def handle_callback(self, api_key: str, username: str, email: str = None) -> bool:
        """处理登录回调"""
        self.api_key = api_key
        self.user_info = UserInfo(
            username=username,
            email=email,
            login_time=datetime.now()
        )
        self._save_session()
        return True
    
    def logout(self):
        """登出"""
        self.api_key = None
        self.user_info = None
        self._clear_session()
```

### 4. 会话存储
- **功能**: 本地保存API密钥和用户信息，避免重复登录
- **实现方式**: 简单的JSON文件存储
- **存储内容**: API密钥、用户名、邮箱、登录时间

```python
def _save_session(self):
    """保存会话信息到JSON文件"""
    session_data = {
        'api_key': self.api_key,
        'user_info': {
            'username': self.user_info.username,
            'email': self.user_info.email,
            'login_time': self.user_info.login_time.isoformat() if self.user_info.login_time else None
        } if self.user_info else None
    }
    
    try:
        with open(self.session_file, "w", encoding='utf-8') as f:
            json.dump(session_data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"Failed to save session: {e}")

def _load_session(self):
    """从JSON文件加载会话信息"""
    try:
        if not os.path.exists(self.session_file):
            return
            
        with open(self.session_file, "r", encoding='utf-8') as f:
            session_data = json.load(f)
            
        self.api_key = session_data.get('api_key')
        user_data = session_data.get('user_info')
        
        if user_data:
            login_time = None
            if user_data.get('login_time'):
                login_time = datetime.fromisoformat(user_data['login_time'])
            
            self.user_info = UserInfo(
                username=user_data['username'],
                email=user_data.get('email'),
                login_time=login_time
            )
    except Exception as e:
        print(f"Failed to load session: {e}")
        self.api_key = None
        self.user_info = None

def _clear_session(self):
    """清除会话文件"""
    try:
        if os.path.exists(self.session_file):
            os.remove(self.session_file)
    except Exception as e:
        print(f"Failed to clear session: {e}")
```

### 5. API密钥使用
- **功能**: 将获取的API密钥用于AI服务调用
- **已实现**: `src/logic/ai_service_manager.py` 中的 `_get_api_key()` 方法
- **逻辑**: 优先使用认证获取的API密钥，回退到环境变量

```python
# src/logic/ai_service_manager.py (需要简化)
def _get_api_key(self, service_name: str) -> str:
    """Get API key for a service - use auth manager if authenticated, otherwise fallback"""
    # If auth manager is available and user is authenticated, use the API key
    if self.auth_manager and self.auth_manager.is_authenticated():
        try:
            api_key = self.auth_manager.get_api_key()
            if api_key:
                return api_key
        except Exception as e:
            self.logger.warning(f"Failed to get API key from auth manager: {e}")
            # Fall through to traditional API key method
    
    # Try environment variable first
    env_key = f"{service_name.upper()}_API_KEY"
    api_key = os.getenv(env_key)
    
    if api_key:
        return api_key
    
    # Fall back to config
    return self.config_manager.get_secret(f"{service_name}_api_key") or ""
```

## 完整实现示例

### 简化的认证管理器 (新建文件)
```python
# src/logic/simple_auth_manager.py
import os
import json
import secrets
import webbrowser
from dataclasses import dataclass
from typing import Optional
from datetime import datetime
from utils.logger import setup_logger, LogCategory

@dataclass
class UserInfo:
    username: str
    email: Optional[str] = None
    login_time: Optional[datetime] = None

class SimpleAuthManager:
    """简化的认证管理器 - 直接处理API密钥和用户信息"""
    
    def __init__(self, login_url: str):
        self.login_url = login_url
        self.api_key = None
        self.user_info = None
        self.session_file = "session.json"
        self.logger = setup_logger(__name__, LogCategory.SECURITY)
        self._load_session()
    
    def login(self) -> bool:
        """启动浏览器登录"""
        try:
            state = secrets.token_urlsafe(16)
            auth_url = f"{self.login_url}?client=reinput&state={state}"
            webbrowser.open(auth_url)
            self.logger.info(f"Browser opened for login: {auth_url}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to start login: {e}")
            return False
    
    def handle_callback(self, api_key: str, username: str, email: str = None) -> bool:
        """处理登录回调"""
        try:
            self.api_key = api_key
            self.user_info = UserInfo(
                username=username,
                email=email,
                login_time=datetime.now()
            )
            self._save_session()
            self.logger.info(f"Login successful for user: {username}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to handle callback: {e}")
            return False
    
    def logout(self):
        """登出"""
        try:
            username = self.user_info.username if self.user_info else "Unknown"
            self.api_key = None
            self.user_info = None
            self._clear_session()
            self.logger.info(f"User logged out: {username}")
        except Exception as e:
            self.logger.error(f"Failed to logout: {e}")
    
    def is_authenticated(self) -> bool:
        """检查是否已登录"""
        return self.api_key is not None and self.user_info is not None
    
    def get_api_key(self) -> Optional[str]:
        """获取API密钥"""
        return self.api_key
    
    def get_user_info(self) -> Optional[UserInfo]:
        """获取用户信息"""
        return self.user_info
    
    def _save_session(self):
        """保存会话信息到JSON文件"""
        session_data = {
            'api_key': self.api_key,
            'user_info': {
                'username': self.user_info.username,
                'email': self.user_info.email,
                'login_time': self.user_info.login_time.isoformat() if self.user_info.login_time else None
            } if self.user_info else None
        }
        
        try:
            with open(self.session_file, "w", encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            self.logger.info("Session saved successfully")
        except Exception as e:
            self.logger.error(f"Failed to save session: {e}")

    def _load_session(self):
        """从JSON文件加载会话信息"""
        try:
            if not os.path.exists(self.session_file):
                return
                
            with open(self.session_file, "r", encoding='utf-8') as f:
                session_data = json.load(f)
                
            self.api_key = session_data.get('api_key')
            user_data = session_data.get('user_info')
            
            if user_data:
                login_time = None
                if user_data.get('login_time'):
                    login_time = datetime.fromisoformat(user_data['login_time'])
                
                self.user_info = UserInfo(
                    username=user_data['username'],
                    email=user_data.get('email'),
                    login_time=login_time
                )
                self.logger.info(f"Session loaded for user: {self.user_info.username}")
        except Exception as e:
            self.logger.error(f"Failed to load session: {e}")
            self.api_key = None
            self.user_info = None

    def _clear_session(self):
        """清除会话文件"""
        try:
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
            self.logger.info("Session cleared")
        except Exception as e:
            self.logger.error(f"Failed to clear session: {e}")
```

## 技术依赖

### Python 标准库模块
```python
import sys
import os
import json
import webbrowser
import winreg
import secrets
from datetime import datetime
from urllib.parse import urlparse, parse_qs
from dataclasses import dataclass
from typing import Optional
```

### 第三方依赖
```python
# 已有的项目依赖，无需额外安装
from PySide6.QtCore import Signal, QTimer
from PySide6.QtWidgets import QLabel, QPushButton
```

### 已有组件 (可复用)
- `src/ui/system_tray.py`: 系统托盘UI - **需要简化认证状态显示**
- `src/ui/settings_dialog.py`: 设置界面UI - **需要简化认证状态显示**
- `src/logic/ai_service_manager.py`: AI服务管理 - **需要简化API密钥获取逻辑**
- `src/utils/config.py`: 配置管理 - **保持不变**
- `src/utils/logger.py`: 日志系统 - **保持不变**

### 需要新建的文件
- `src/logic/simple_auth_manager.py`: 简化的认证管理器 (替代复杂的 `auth_manager.py`)

## 环境配置

```env
# 登录页面URL
AUTH_FRONTEND_URL=http://localhost:5174

# 回退API密钥（可选）
OPENAI_API_KEY=sk-your-fallback-key
```

## 需要移除的功能

以下当前实现的功能**不再需要**:
- JWT解析和验证逻辑
- DPAPI加密存储
- 授权码交换机制
- 复杂的异常处理类
- 网关代理功能（除非后端需要）
- 异步认证方法
- 服务端用户信息刷新

## 实现估算

- **代码量**: 约200-300行（相比当前1000+行大幅简化）
- **核心文件**: 
  - 新建: `src/logic/simple_auth_manager.py` (~150行)
  - 修改: `src/main.py` URL处理逻辑 (~50行修改)
  - 修改: `src/logic/ai_service_manager.py` API密钥获取 (~20行修改)
  - 修改: `src/ui/system_tray.py` 状态显示 (~30行修改)
  - 修改: `src/ui/settings_dialog.py` 状态显示 (~30行修改)
- **开发时间**: 1-2天重构现有代码

## 测试要点

1. **浏览器登录**: 点击登录按钮能正确打开浏览器到指定URL
2. **URL回调解析**: `reinput://auth/callback?api_key=xxx&username=xxx` 能正确解析
3. **会话持久化**: 登录信息能正确保存到 `session.json` 并在重启后加载
4. **UI状态更新**: 系统托盘和设置界面能正确显示登录状态和用户信息
5. **API密钥使用**: AI服务能正确使用认证获取的API密钥
6. **登出功能**: 登出能正确清除本地数据和UI状态
7. **错误处理**: 网络错误、文件错误等异常情况能正确处理
8. **状态码验证**: URL回调中的state参数能正确验证（防止CSRF攻击）

## 迁移步骤

### 客户端迁移
1. **创建新的认证管理器**: 实现 `SimpleAuthManager`
2. **修改主应用**: 更新 `main.py` 中的URL处理逻辑
3. **更新AI服务管理**: 简化 `ai_service_manager.py` 中的API密钥获取
4. **简化UI显示**: 更新系统托盘和设置界面的状态显示
5. **移除旧代码**: 删除复杂的JWT处理、DPAPI加密等不需要的功能
6. **测试验证**: 完整测试登录、登出、API调用等功能